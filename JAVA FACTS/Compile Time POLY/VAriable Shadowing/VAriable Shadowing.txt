Great question! Let's clarify this important concept in Java: **Can we override non-static variables in subclasses?**

---

## ðŸ”¸ Q8: Can we override non-static variables in subclasses?

### âœ… Answer:

> **No, variables (both static and non-static) in Java are not overridden â€” they are shadowed.**

---

## ðŸ” Explanation:

* **Methods** in Java are overridden.
* **Variables** are not overridden â€” they are **shadowed/hide** the superclass variable.

---

### ðŸ§ª Example:

```java
class A {
    int x = 10;
}

class B extends A {
    int x = 20;  // This shadows A.x
}
```

### ðŸ”¸ Case 1: Using subclass reference

```java
B obj = new B();
System.out.println(obj.x);  // Output: 20
```

> âœ… Here, `obj` is of type `B`, so it accesses `B`'s version of `x`.

---

### ðŸ”¸ Case 2: Using superclass reference

```java
A obj = new B();
System.out.println(obj.x);  // Output: 10
```

> â— Even though the object is of type `B`, the reference is of type `A`.
> So the **field access uses the reference type**, not the object type.

---

## ðŸ” Why doesn't this happen with methods?

```java
class A {
    void show() { System.out.println("A"); }
}

class B extends A {
    void show() { System.out.println("B"); }
}

A obj = new B();
obj.show();  // Output: B âœ… (Overridden method)
```

> ðŸ”¥ **Dynamic dispatch** works for methods, not for variables.

---

## âœ… Summary Table:

| Member Type | Can Be Overridden? | Behavior with Superclass Reference |
| ----------- | ------------------ | ---------------------------------- |
| Method      | âœ… Yes              | Uses **object type**               |
| Variable    | âŒ No (shadowed)    | Uses **reference type**            |

---

### ðŸ§  Interview Tip:

> This is a **classic trap question** â€” candidates often assume variables behave like methods in polymorphism, but they don't.

---

Would you like a challenge quiz or another variation with `static` fields?
